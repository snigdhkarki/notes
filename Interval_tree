Interval tree
It uses Red black tree as underlying data structure. An [a,b] interval is denoted by an object i with i.low = a and i.high = b. Each node in the tree has a attribute x.int and a key that contains the lower end of interval it denotes i.int.low. It has the additional information x.max that contains the maximum value of upper end of interval present at the subtree rooted at x. It maintain the attribute in modifying operation insert and delete as for any node x, x.max = max(x.int.high, x.left.max, x.right.max). We add the new operator Search(T, i) which returns the node containing interval that overlaps with interval i. Intervals i and i' have following relations:
1) i.high >= i'.low and i'.high >= i.low then i and i' overlap 
2) i.high < i'.low then i is non overlapping and behind of i'
3) i'.high < i.low then i is non overlapping and ahead of i'
This also satisfies the property of trichotomy

Search(T, i): starts with x as the root. It has a while loop that make x go to left child if x.left.max >= i.low.Else it goes to the right child. It returns x if x and i overlap. The while loop has loop invarient "If overlapping interval to i is present in tree T then it is present in subtree rooted at x". It is the same as saying the contrapositive invarient "If overlapping interval to i is not present at x then it is not present anywhere else". It can be proved that the original invarient is maintained when x goes to the right since that would imply x.left.max < i.low so no overlapping in left present. The contrapositive invarient is maintained when x goes to the left since that would imply x.left.max >= i.low or there is a interval i' in subtree of left child i' such that i'.high >= i.low or i'.high < i.low is not true. Since the assumption in the contrapositive invarient is that x does not have any element overlapping with i, i' and i dont overlap either. Thus from trichotomy i.high<i'.low. Since all intervals of right child(say i") are such that for any interval in left(including i') i'low<i".low so we can say i.high<i".low so there is no overlapping interval in right child subtree

