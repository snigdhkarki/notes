Binary tree
It satisfies the property that if y is a node that lies in the left subtree of x then y.key<x.key and if y is a key that lies in the right subtree of x then y.key>x.key. It is used when we require operations Search, Maximum, Minimum, Successor, Predessesor, Insert and Delete. It can print all the numbers in order by calling sort recursively on both sub trees in O(n) time. It can Search by recursively calling on one subtree in O(h) time where h is the height of binary tree. It can find Maximum and Mimimum in the same way in O(h) time. It can find the predessesor and successor by finding the minumum or maximum on one of its subtree. It will always lie in the subtree and not anywhere else because in binary tree:
elsewhere<leftsubtree<x<rightsubtree<elsewhere
Hence it can be found in O(h) time. Insert takes as input a node with both children being null and starts checking from the root and finds a path to a suitable leaf and puts the node as a child of the leaf taking O(h) time. Worst case is when the the input data arrive at incresing or decreasing order causing the height to be equal to the no of data. Delete takes as input a node and simply replace the node with null if it has no children, replace the node with one of its child if it has null as the other child. If the node to be deleted(say z) has both childern then it finds the minimum node in its right subtree say y. Since y is the minimum node it only has a right child (say x). We replace z with y and have the left subtree of y as left subtree of z and the right subtree of y as right subtree of z(with y being replaced by x).Delete also uses the subroutine trasplant thats why we cant use a heap like thing instead of binary tree.



